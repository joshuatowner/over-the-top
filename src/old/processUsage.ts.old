import Two = require("two.js");
import {ProcessCurrentUsage} from "../../worker/processCurrentUsage";
import {getRandomColor} from "../../util/color";
import {BACKGROUND_COLOR} from "../constants/styles";

export default class ProcessUsage {

    two: Two;
    center: Point;
    innerRadius: number;
    outerRadius: number;
    padding: number
    processGraphics: Two.ArcSegment[];
    processes: ProcessCurrentUsage[];
    colors: {[key:string]: string};

    constructor(
        two: Two,
        center: Point,
        innerRadius: number,
        outerRadius: number,
        padding = 5
    ) {
        this.two = two;
        this.center = center;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        this.padding = padding;
        this.processGraphics = [];
        this.processes = [];
        this.colors = {};
    }

    draw(): void {
        let curAngle = 0;

        for (let i = 0; i < this.processes.length; i++) {
            const proc = this.processes[i];
            const endAngle = curAngle + (2 * Math.PI * (proc.usage))
            const arc = this.two.makeArcSegment(
                this.center.x,
                this.center.y,
                this.innerRadius,
                this.outerRadius,
                curAngle,
                endAngle,
                100
            );

            if (!this.colors[proc.name]) {
                this.colors[proc.name] = getRandomColor();
            }
            arc.fill = this.colors[proc.name];
            arc.stroke = BACKGROUND_COLOR.hex();
            arc.linewidth = 5

            this.processGraphics[i] = arc;
            curAngle = endAngle;
        }
    }

    update(newLevels: ProcessCurrentUsage[]): void {
        this.processGraphics.map((arc) => arc.remove());
        newLevels.sort((a, b) => b.usage - a.usage);
        newLevels = this.pruneOthers(newLevels);
        this.processes = newLevels;
        this.draw();
        this.two.update();
    }

    pruneOthers(levels: ProcessCurrentUsage[]): ProcessCurrentUsage[] {
        const sumReducer = (sum: number, item: ProcessCurrentUsage) => sum + item.usage;

        const total = levels.reduce(sumReducer, 0);
        let adjusted = levels.map(level => ({
            name: level.name,
            usage: level.usage / total
        }));

        adjusted = adjusted.reduce((list, level) => {
            const name = level.name;
            const usage = level.usage;
            const existing = list.find(lev => lev.name === name);
            if (existing) {
                existing.usage += usage;
            } else {
                list.push({name, usage});
            }
            return list;
        }, [] as ProcessCurrentUsage[]);
        adjusted = adjusted.filter(level => level.usage >= 0.02);
        adjusted.push({
            name: "other",
            usage: 1.0 - adjusted.reduce(sumReducer, 0)
        })

        return adjusted;
    }

}
